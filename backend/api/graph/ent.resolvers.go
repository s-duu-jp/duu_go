package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.49

import (
	"api/ent"
	"api/ent/user"
	"api/graph/model"
	"context"
	"fmt"
	"strconv"
)

// Node is the resolver for the node field.
func (r *queryResolver) Node(ctx context.Context, id string) (ent.Noder, error) {
	panic(fmt.Errorf("not implemented: Node - node"))
}

// Nodes is the resolver for the nodes field.
func (r *queryResolver) Nodes(ctx context.Context, ids []string) ([]ent.Noder, error) {
	panic(fmt.Errorf("not implemented: Nodes - nodes"))
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, after *string, first *int, before *string, last *int, where *model.UserWhereInput) (*model.UserConnection, error) {
	fmt.Print("Users")

	query := r.client.User.Query()

	if where != nil {
		if where.Name != nil {
			query = query.Where(user.NameEQ(*where.Name))
		}
		if where.Email != nil {
			query = query.Where(user.EmailEQ(*where.Email))
		}
	}

	var users []*ent.User
	var err error

	if first != nil {
		users, err = query.Limit(*first).All(ctx)
	} else if last != nil {
		users, err = query.Limit(*last).All(ctx)
	} else {
		users, err = query.All(ctx)
	}

	if err != nil {
		return nil, fmt.Errorf("failed to query users: %w", err)
	}

	userEdges := make([]*model.UserEdge, len(users))
	for i, user := range users {
		cursor := fmt.Sprintf("%d", user.ID)
		userEdges[i] = &model.UserEdge{
			Node: &model.User{
				ID:         strconv.Itoa(user.ID),
				Sid:        user.Sid,
				UID:        user.UID,
				Name:       user.Name,
				Email:      user.Email,
				RoleType:   user.RoleType,
				StatusType: user.StatusType,
				OauthType:  user.OauthType,
			},
			Cursor: cursor,
		}
	}

	userConnection := &model.UserConnection{
		Edges:    userEdges,
		PageInfo: &model.PageInfo{},
	}

	if len(userEdges) > 0 {
		startCursor := userEdges[0].Cursor
		endCursor := userEdges[len(userEdges)-1].Cursor
		userConnection.PageInfo.StartCursor = &startCursor
		userConnection.PageInfo.EndCursor = &endCursor
		userConnection.PageInfo.HasNextPage = len(users) == *first
	}

	return userConnection, nil
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
